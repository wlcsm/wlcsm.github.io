<?xml version="1.0" encoding="utf-8" standalone="yes"?>
<rss version="2.0" xmlns:atom="http://www.w3.org/2005/Atom">
  <channel>
    <title>Posts on </title>
    <link>http://example.org/posts/</link>
    <description>Recent content in Posts on </description>
    <generator>Hugo -- gohugo.io</generator>
    <language>en-us</language>
    <copyright>Copyright Will Cashman 2022.</copyright>
    <lastBuildDate>Sat, 06 Nov 2021 00:00:00 +0000</lastBuildDate><atom:link href="http://example.org/posts/index.xml" rel="self" type="application/rss+xml" />
    <item>
      <title>Neovim Async Jobs (No Plugins)</title>
      <link>http://example.org/posts/neovim-async-jobs/</link>
      <pubDate>Sat, 06 Nov 2021 00:00:00 +0000</pubDate>
      
      <guid>http://example.org/posts/neovim-async-jobs/</guid>
      <description>Neovim introduced asynchronous job control which load to plugins enabling you to run shell commands without blocking Vim, most notably the fantastic (Neomake) plugin. For my development however, I only really need to run shell commands asynchronously and load the data into the quickfix list.
Neomake is great, but it&amp;rsquo;s also 13000+ lines of code, this is one:
1 2 command! -nargs=+ AsyncRun call jobstart([&amp;#39;sh&amp;#39;, &amp;#39;-c&amp;#39;, &amp;#39;&amp;lt;args&amp;gt; &amp;gt; /tmp/run.log 2&amp;gt;&amp;amp;1&amp;#39;], \ {&amp;#39;on_exit&amp;#39;: {-&amp;gt; execute(&amp;#39;cfile /tmp/run.</description>
    </item>
    
    <item>
      <title>Trick for Managing Neovim Terminals</title>
      <link>http://example.org/posts/managing-vim-terminals/</link>
      <pubDate>Sun, 24 Oct 2021 00:00:00 +0000</pubDate>
      
      <guid>http://example.org/posts/managing-vim-terminals/</guid>
      <description>I&amp;rsquo;ve recently been use Neovim&amp;rsquo;s terminals a lot more recently and I&amp;rsquo;ve found that I spend a lot of time doing
:term &amp;lt;TAB&amp;gt; to find the terminal with my tests. Then &amp;lt;C-&amp;gt;&amp;lt;C-^&amp;gt; to get back to the file that I was editing, and if I have more than one terminal open it isn&amp;rsquo;t easy to remember which terminal has my tests it in, which terminals had another thing, and so on.</description>
    </item>
    
    <item>
      <title>Using Errgroup</title>
      <link>http://example.org/posts/errgroup/</link>
      <pubDate>Fri, 01 Oct 2021 00:00:00 +0000</pubDate>
      
      <guid>http://example.org/posts/errgroup/</guid>
      <description>Here I&amp;rsquo;m going to illustrate a couple of common use case for the errgroup, and in particular some in which you may think the errgroup is too fundamental but is in fact not.
Run many things in parallel and return if there is an error or a certain response For instance, multiple validation functions, and immediately return if an error is returned or a function failed. Or to poll multiple data centers for a result and immediately return the first one.</description>
    </item>
    
    <item>
      <title>A Vim Purist&#39;s Workflow</title>
      <link>http://example.org/posts/vim-workflow/</link>
      <pubDate>Fri, 01 Jan 2021 00:00:00 +0000</pubDate>
      
      <guid>http://example.org/posts/vim-workflow/</guid>
      <description>I have been using Vim for about 1.5 years now and I am constantly surprised about how many features it has.
Despite using it for many smaller projected, I wasn&amp;rsquo;t sold on using Vim as my main programming environment, and even then, it was only with CoC installed to essentially replicate VS Code in Vim. Until I stumbled across this video by Leeren at VimConf . This completely blew my mind (as did his other videos on Vim).</description>
    </item>
    
    <item>
      <title>Bulk Rename Script</title>
      <link>http://example.org/posts/interactive-bulk-rename-script/</link>
      <pubDate>Fri, 01 Jan 2021 00:00:00 +0000</pubDate>
      
      <guid>http://example.org/posts/interactive-bulk-rename-script/</guid>
      <description>I spend pretty much all my time in the terminal. After some time, I find I can navigate just as fast, if not faster there than in a GUI file browser.
I used to use the ultra-lightweight nnn terminal file browser, but even that I found unnecessary other than being very nice to look at.
The one feature that I missed however, was bulk renaming files in my editor. When you press r in nnn, it brings up the files in the directory in the program specified in your $EDITOR variable, with numbers next to them.</description>
    </item>
    
    <item>
      <title>Mail Setup</title>
      <link>http://example.org/posts/mail-setup/</link>
      <pubDate>Fri, 01 Jan 2021 00:00:00 +0000</pubDate>
      
      <guid>http://example.org/posts/mail-setup/</guid>
      <description>Email My email setup is a little complicated because I maintain a local copy of my mail on my computer for backup reasons. It is also nice because it is faster. I use Neomutt which is a terminal based email client. This is because I like the minimalism and I just think that email is something that is so fundamental that it should be in a terminal. I have tried other lightweight clients like Sylpheed and I still prefer it.</description>
    </item>
    
    <item>
      <title>Monitoring Cryptocurrencies with Bash</title>
      <link>http://example.org/posts/crypto-bash-script/</link>
      <pubDate>Fri, 01 Jan 2021 00:00:00 +0000</pubDate>
      
      <guid>http://example.org/posts/crypto-bash-script/</guid>
      <description>I bought into the crypto scene but was concerned about the price of crypto dropping dramatically as it does, so I made an incredibly basic bash script to monitor the prices of crypto using the CoinGecko API. This could be used for instance to show the current price on Bitcoin in PolyBar or DWM
1 2 3 4 5 6 7 #!/bin/sh COINS=$1 CURRENCIES=$2 curl -X GET &amp;#34;https://api.coingecko.com/api/v3/simple/price?ids=${COINS}&amp;amp;vs_currencies=${CURRENCIES}&amp;#34; -H &amp;#34;accept: application/json&amp;#34; echo &amp;#34;&amp;#34; Save this to a file fetch-crypto.</description>
    </item>
    
    <item>
      <title>On Motivations (Unedited)</title>
      <link>http://example.org/posts/on-motivations/</link>
      <pubDate>Fri, 01 Jan 2021 00:00:00 +0000</pubDate>
      
      <guid>http://example.org/posts/on-motivations/</guid>
      <description>I have found that doing a side project scratched the itch I had for programming
This was quite unexpected as I always thought programming was the thing I enjoyed the most, the end. But now I feel free to use it as a means to an end.
This had a surprise benfit of saving me from doing a potentially unhappy PhD. I always had a love for pure mathematics. The elegance and perfection in it has also strongly shaped my programming style, in perhaps an unhelpful way.</description>
    </item>
    
    <item>
      <title>Vim Features: Tags list</title>
      <link>http://example.org/posts/vim-lesson-tags/</link>
      <pubDate>Fri, 01 Jan 2021 00:00:00 +0000</pubDate>
      
      <guid>http://example.org/posts/vim-lesson-tags/</guid>
      <description>This is how you get that IDE like feeling where you can navigate around codebases super fast. This is built-in, no plugins, no configurations
What are tags Tags are an outline of your codebase, they record the location of important definitions like functions, type definitions, class definitions.
Getting Started Download ctags, also known as Exhuberant Tags, and run ctags -R . in your project root directory. Unless your codebase is quite large, this should be close to instaneous.</description>
    </item>
    
    <item>
      <title>Vim for Git Merging</title>
      <link>http://example.org/posts/vim-mergetool/</link>
      <pubDate>Fri, 01 Jan 2021 00:00:00 +0000</pubDate>
      
      <guid>http://example.org/posts/vim-mergetool/</guid>
      <description>This is the config for my vim setup for resolving git merge conflicts.
[alias] mt = mergetool -t vimdiff [mergetool] writeToTemp = true [mergetool &amp;#34;vimdiff&amp;#34;] cmd = nvim -d $MERGED $LOCAL $BASE $REMOTE -c &amp;#39;wincmd J&amp;#39; The alias mt means I can type git mt rather than the more verbose git mergetool -t vimdiff writeToTemp makes git put the BASE, LOCAL, REMOTE files into your computer&amp;rsquo;s temp directory. BASE The file before the conflicting changes</description>
    </item>
    
    <item>
      <title>Vim for Software Development</title>
      <link>http://example.org/posts/vim-as-developer/</link>
      <pubDate>Fri, 01 Jan 2021 00:00:00 +0000</pubDate>
      
      <guid>http://example.org/posts/vim-as-developer/</guid>
      <description>It is no secret that Vim has fallen behind the times when it comes to software develpment. Not to say that it has strayed from its original design and purpose i.e. editing text. But that the times have changed such that this is no longer satisfies the needs of many developers
When I see people talk about using Vim for software development, it is a general concensus that you must load it full of plugins to get that VSCode feeling back.</description>
    </item>
    
    <item>
      <title>Vim&#39;s Quickfix/Location list</title>
      <link>http://example.org/posts/vim-lesson-quickfix-list/</link>
      <pubDate>Fri, 01 Jan 2021 00:00:00 +0000</pubDate>
      
      <guid>http://example.org/posts/vim-lesson-quickfix-list/</guid>
      <description>People often complain that Vim doesn&amp;rsquo;t have good support for project-wide searches or error navigation without the use of plugins or even LSPs. These people have clearly never learned about Vim&amp;rsquo;s inbuilt quickfix and location list.
Quickfix list The quickfix list is a buffer in Vim which provides fast navigation to locations in files.
Differences between the Quickfix and Location list The two are exactly the same, however there is only one quickfix list per Vim session, but there is one location list for every window.</description>
    </item>
    
    <item>
      <title></title>
      <link>http://example.org/posts/leaving-bytedance/</link>
      <pubDate>Mon, 01 Jan 0001 00:00:00 +0000</pubDate>
      
      <guid>http://example.org/posts/leaving-bytedance/</guid>
      <description>Note that I haven&amp;rsquo;t actually leaft ByteDance at the moment, but just are now clear that this is what I want to do.
This was brought about after I was invited to go on a business trip to America for 2 and a half months, my girlfriend thought that this was perhaps way too long and remarked that if I work there for nearly three months, then I may as we just work there.</description>
    </item>
    
    <item>
      <title></title>
      <link>http://example.org/posts/sed-markdown-compiler/</link>
      <pubDate>Mon, 01 Jan 0001 00:00:00 +0000</pubDate>
      
      <guid>http://example.org/posts/sed-markdown-compiler/</guid>
      <description>&amp;ldquo;Markdown to HTML Using sed&amp;rdquo; I recently discovered the :TOhtml command in Vim. It converts the current view of the file you are editing in Vim to HTML that can be viewed in the browser. TODO I think it has some other use cases too
However, it would be nice if it could actually render the Markdown file I was editing too. I looked at the common solutions like pandoc but I found that they were incredibly huge programs.</description>
    </item>
    
  </channel>
</rss>
